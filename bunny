#! /bin/bash
#
# Copyright (c) 2017-2018 ypsah
# Licensed under MIT (https://github.com/ypsah/bunny/blob/master/LICENSE.txt)
#

function usage()
{
    printf 'usage: %s [-h] [--] [SUITE[:TEST] ...]

Discover and/or run a list of tests and test suites

Optional arguments:
    -h, --help  Display this message

Positionnal arguments:
    SUITE       The name of a test suite (the path to the bash source file)
    TEST        The name of a test in the SUITE it is prefixed by
' "${BASH_SOURCE[0]##*/}"
}

while [ $# -gt 0 ]; do
    if [ "${1:0:1}" == '-' ] && [ "${1:1:1}" != '-' ] && [ ${#1} -gt 2 ]; then
        set -- "${1:0:2}" "-${1:2}" "${@:2}"
    fi
    case "$1" in
    -h|--help)
        usage
        exit 0
        ;;
    -[^-]|--?*)
        usage
        printf '\n'
        printf 'unknown option %s\n' "$1"
        exit 64
        ;;
    --)
        shift
        ;&
    *)
        break
        ;;
    esac
    shift
done

declare -A TESTS
declare -a SUITES

for arg; do
    if [[ "${arg##*/}" =~ : ]]; then
        # test names cannot contain spaces => space can be used as a separator
        TESTS["${arg%:*}"]+="${arg##*:} "
    else
        SUITES+=("$arg")
    fi
done

function list_tests()
{
    for suite in "${!TESTS[@]}"; do
        local tests
        IFS=" " read -ra tests <<< "${TESTS[$suite]}"
        printf "$suite:%s\\0" "${tests[@]}"
    done

    [ ${#SUITES[@]} -eq 0 ] && [ ${#TESTS[@]} -gt 0 ] && return 0

    while IFS="" read -rd $'\0' suite; do
        (
            source "$suite"

            local tests
            mapfile -t tests < <(declare -F | cut -d' ' -f3 | grep "^test_")
            printf "$suite:%s\\0" "${tests[@]}"
        )
    done < <(find "${SUITES[@]}" -path '*/.log' -prune \
                              -o -type f -name "test*" -print0)
}

# Declare some useful variables
printf -v now "%(%T)T" "-1"
declare -x now="${now//:/-}"

here="$(readlink -m "${BASH_SOURCE[0]}")"
declare -x harness="${here%/*}"/harness.sh

function __test_run()
{
    local suite="${1%:*}"
    local test="${1##*:}"

    # Set up the log directory
    local logfile
    logfile="$(dirname "$suite")/.log/$now/$test.log"
    mkdir -p "${logfile%/*}"
    rm -f "$logfile"

    # Run the test
    (
    local -i start nano_start end nano_end
    local nano_elapsed
    IFS=" " read -r start nano_start <<< "$(date '+%s %-N')"

    source "$harness"
    source "$suite"
    declare -F setup >/dev/null && setup
    ( "$test" )
    case $? in
        0)
            local status=Passed
            ;;
        75)
            local status=Skipped
            ;;
        *)
            local status=Failed
            ;;
    esac

    declare -F teardown > /dev/null && teardown
    IFS=" " read -r end nano_end <<< "$(date '+%s %-N')"
    if ((nano_end < nano_start)) ||
        { ((nano_end == nano_start)) && ((end > start)); }; then
        nano_end+=1000000000
        ((end--))
    fi
    printf -v nano_elapsed '%0.9i' $((nano_end - nano_start))

    printf '\n%s in %i.%ss\n' $status "$((end - start))" "${nano_elapsed:0:3}"
    ) > "$logfile" 2>&1
}
export -f __test_run

# Run tests
list_tests | xargs -0 -I{} -P "$(nproc)" \
    bash -c ' __test_run "$1"' -- "{}"

declare -i total=0 skipped=0 failures=0
function __test_report()
{
    local suite="${1%:*}"
    local test="${1##*:}"
    local logfile
    logfile="$(dirname "$suite")/.log/$now/$test.log"

    printf '%s\n' "${suite#./}:$test"
    printf '%80s\n' "" | tr ' ' '-'
    cat "$logfile"
    printf '\n\n'

    case "$(tail -n 1 "$logfile" | cut -d" " -f1)" in
        Failed)
            failures+=1
            ;;
        Skipped)
            skipped+=1
            ;;
    esac
    total+=1
}

# Generate the report
while IFS="" read -rd $'\0' test_name; do
    __test_report "$test_name"
done < <(list_tests)

printf "Ran %i tests: %i passed" $total $((total - failures - skipped))
[ $skipped -gt 0 ] && printf ", %i skipped" $skipped
[ $failures -gt 0 ] && printf ", %i failed" $failures
printf '\n'

[ $failures -eq 0 ]
